In this repository will be described main questions from interviews for C# and Angular.

# The interview questions C#.

Вопросы:
0. ### Модификаторы доступа
 - **public**: Неограниченный доступ.  
 - **private**: Доступ ограничен содержащим типом.   
 - **protected**: Доступ ограничен содержащим классом или типами, которые являются производными от содержащего класса. 
 - **private protected**: Доступ ограничен содержащим классом или типами, которые являются производными от содержащего класса в текущей сборке. Доступно с версии C# 7.2.  
 - **internal**: Доступ ограничен текущей сборкой.  
 - **protected internal**: Доступ ограничен текущей сборкой или типами, которые являются производными от содержащего класса.  

___
1. ### ООП

**Класс** – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт).  

**Объект (экземпляр)** – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом.  

**Интерфейс** – это набор методов класса, доступных для использования другими классами(Обязательный контракт на который подписывается класс при реализации данного интерфейса).  

**Инкапсуляция** – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя. Являесться "защитой" кода от вмешательств из вне.  

**Абстрагирование** – это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. Соответственно, абстракция – это набор всех таких характеристик.  

**Полиморфизм** - это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта. К примеру у нас есть класс Shape. И есть классы наследуемые от него - Circle and Rectangle. Оба реализуют метод GetSquare (описанный в Shape) по-разному. В классе наследуемом - virtual. В классе наследнике - override.  

**Наследование** – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом. Множественное наследование производится только с помощью интерфейсов. Множественное наследование классов исключено для избежание ромбовидных наследований( A -> B:A, C:A-> D:B,C )  

**Делегирование** — процесс передачи полномочий или части полномочий сотрудникам (подчиненным).  Делегирование — это способ эффективного управления, при котором происходит передача задачи, а также полномочий и ответственности на выполнение другим лицам.  
___
2. ### Что такое CLR? Что такое IL? Что такое CLS?
**CLR** - common language runtime. Существуют компиляторы, которые были специально созданы для данной платформы. CLR - все равно на каком языке был написан исходный код. Результатом компилятора является **managed module (управляемый модуль)**, который и требует CLR. 

**IL** - intermediate language. Код создаваемый компилятором при компиляции исходного кода. Далее CLR компилирует его в машинные команды. 

**CLS** - common language specification. Набор правил, следуя которым, разработчик может избежать кофликтов в работе со всеми языками .net.

___
3. ### Что такое managed code? Unmanaged code?

`manged code` - управляемый код. Служит для выполнения в среде CLR. В связи с этим на него накладываются некоторые ограничения. Основные приемущества - управление памятью, возможность программировать на различных языках, повышение безопасности, поддержка уравления версиями, четкая организация управления программных компонентов. 

`unmanaged code` - неуправляемый код. Не используется для выполенния в CLR. Может взаимодействовать с управляемым кодом, а значит на него не накладываются ограничения. 

___
4. ### Что такое assembly?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Наименьшая единица многократного использовния, безопасности и управления версиями. 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Обеспечивает логическую группировку одного или нескольких управляемых модулей или файлов ресурсов. 
Способ объединения нескольких файлов в единую сущность. 

Сборки имеют следующие свойства:  
 - Сборки реализованы как файлы EXE или DLL.  

 - Для библиотек, предназначенных для .NET Framework, сборки можно совместно использовать в нескольких приложениях, поместив их в глобальный кэш сборок (GAC). Прежде чем включить сборки в глобальный кэш сборок, нужно назначить им строгие имена(с помощью `gacutil.exe`). 

 - Сборки загружаются в память только в том случае, если они реально используются. Если они не используются, то они не загружаются. Благодаря этому свойству сборки могут быть эффективным средством для управления ресурсами в крупных проектах.  

 - Сведения о сборке можно получить программным путем с помощью Рефлексии.  

 - Сборку можно загрузить только для ее проверки, используя класс ```MetadataLoadContext``` в .NET Core и методы ```Assembly.ReflectionOnlyLoad``` или ```Assembly.ReflectionOnlyLoadFrom``` в .NET Core и .NET Framework.  

___
5. ### Что такое assembly manifest?
Манифест сборки -    это внутренняя часть сборки, которая позволяет ей быть самоописанной.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Каждая сборка, статическая или динамическая, содержит набор данных, который описывает, как элементы в сборке связаны друг с другом. Манифест сборки содержит эти метаданные сборки. Манифест сборки содержит все метаданные, необходимые для указания требований к версии сборки и идентификатора безопасности, а также все метаданные, необходимые для определения области сборки и разрешения ссылок на ресурсы и классы. Манифест сборки может храниться либо в PE-файле (.exe или .dll) с кодом промежуточного языка Microsoft (MSIL), либо в отдельном PE-файле, который содержит только информацию о манифесте сборки.

![Assembly types diagram](/img/assembly-types-diagram.gif)

Для сборки с одним связанным файлом манифест включается в PE-файл для формирования сборки из одного файла. Вы можете создать многофайловую сборку с помощью отдельного файла манифеста или с помощью манифеста, включенного в один из файлов PE в сборке.

Каждый манифест сборки выполняет следующие функции:  
 - перечисляет файлы, из которых состоит сборка;
 - сопоставление ссылок на типы и ресурсы сборки с файлами, содержащими объявления и реализации этих типов и ресурсов;
 - перечисление других сборок, от которых зависит эта сборка;
 - обеспечение косвенного обращения пользователей сборки к подробностям ее реализации;
 - предоставление собственного описания сборки

 ### Что включает в себя манифест сборки

 Таблица внизу показывает всю информацию, которая включена в файл манифеста сборки. Первые четыре элемента: assembly name, version number, culture, and strong name information формируют идентификатор сборки. 

![Assembly manifest table](/img/assembly-manifest.png)

С помощью задания атрибутов сборки в коде можно добавить или изменить некоторые данные в манифесте сборки. Можно изменить данные о версии и информационные атрибуты, включая сведения о товарном знаке, авторском праве, продукте, компании и информационной версии. 

___
6. ### Что такое приватные и совместные сборки?

Сборки бывают 2х типов: приватные (те, которые используют само приложение) и совместные (использующие набор приложений).

При приватных сборках приложение изолируется от внешнего воздействия операционной системы и програм. Так же уже не необходимо париться на счёт уникальности имён в глобальном пространстве.

Что б сделать сборку совместной - нужно её собрать и присвоить ей строгое шифрованное имя.

___
7. ### В чем различие между Value Type и Reference Type?
**Value Type(byte, sbyte, short, ushort, int, uint, long, ulong, float, double, decimal, bool, char, enum, struct)**:  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Сохраняет некоторые значения, а не адреса памяти.*  
**Место хранения:**  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Типы значений сохраняются там, где они объявлены. Например: значение int внутри функции как локальной переменной будет храниться в стеке, тогда как значение int объявленное как член в классе, будет храниться в куче с классом, в котором он объявлен. Тип значения в классе имеет тип lifetype, который точно такой же, как класс, в котором он объявлен, требуя почти никакой работы сборщиком мусора.  
  
**Преимущества:**  
  - Тип значения не требует дополнительной сборки мусора. Он получает мусор, собранный вместе с экземпляром, в котором он живет. Локальные переменные в методах очищаются при отпускании метода.  
  
**Недостатки:**  
  - Когда большой набор значений передается методу, принимающая переменная фактически копируется, поэтому в памяти есть два избыточных значения.  

**Reference Type(object, string, class, interface, delegate**:  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Удерживает адрес памяти значения не value.*  
**Место хранения:**  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Сохранено в куче.  

**Преимущества:**  
 - Когда вы передаете ссылочную переменную методу и он меняет, он действительно изменяет исходное значение, тогда как в типах значений берется копия данной переменной и это значение изменяется.
 - Когда размер переменной больше ссылочного типа, это хорошо.
 - Поскольку классы относятся к переменным ссылочного типа, они дают возможность повторного использования, что приносит пользу объектно-ориентированному программированию.  
 
**Недостатки:**  
 - Больше ссылок на работу при распределении и разыменованиях при чтении значения. Дополнительная перегрузка для сборщика мусора

___
8. ### Про сборщик мусора. Когда объект удаляется сборщиком мусора?  
+  

___
9. ### Что такое Code Access Security (CAS)?  
`Code Access Security` — механизм защиты, позволяющий ограничивать доступ коду к ресурсам компьютера. Используется в среде .NET Framework. Используется для определения разрешений и установки прав доступа к различным системным ресурсам, позволяет администраторам настраивать политику безопасности с помощью предоставления доступа различному коду к определённым ресурсам. Код группы содержит одно или более разрешений.  

Например, коду, написанному Microsoft, могут быть предоставлены привилегии для записи на диск, а коду от другой компании в этом отказано.  

Источник - [https://en.wikipedia.org/wiki/Code_Access_Security]  

___
10. ### Что такое attribute?  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Атрибуты в .NET представляют специальные инструменты, которые позволяют встраивать в сборку дополнительные метаданные. Атрибуты могут применяться как ко всему типу (классу, интерфейсу и т.д.), так и к отдельным его частям (методу, свойству и т.д.). Основу атрибутов составляет класс System.Attribute, от которого образованы все остальные классы атрибутов.  

Пример класса атдибута:  

```c#
 public class AgeValidationAttribute : System.Attribute
{
    public int Age { get; set; }
     
    public AgeValidationAttribute()
    { }
     
    public AgeValidationAttribute(int age)
    {
        Age = age;
    }
}
```
С помощью атрибута AttributeUsage можно ограничить типы, к которым будет применяться атрибут.  
```c#
[AttributeUsage(AttributeTargets.Class)]
public class RoleInfoAttribute : System.Attribute
{
  // ...
}
```  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ряд ограничений: All, Assembly, Constructor, Delegate, Enum, Event, Field, Interface, Method, Property, Struct. Их можно комбиноровать с помощью опретора или(|). 
```c# 
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
```

___
11. ### Как обеспечить использование именованных параметров в конструкторе атрибута?  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При проектировании *Атрибута*, требуеться объявлять поля и свойсва как публичные, тк при задании именного параметра в конструктор атрибута передается имя свойства или поля, которое должно принять этот параметр. При этом они должны иметь свойство доступа ```public```.  
Для примера примеведен атрибут с двумя полями(Id, Name), которые являются открытыми:  
```c#
public class TestAttribute : System.Attribute
{
	private string _name;
	public int A;
	public int B;
	public int C;
	
	public TestAttribute(string name)
	{
		this._name = name;
	}
	
	public TestAttribute(string name, int a, int b, int c)
	{
		this._name = name;
		this.A = a;
		this.B = b;
		this.C = c;		
	}
}

// Именованные параметры являются необязательными и могут указываться в любом порядке.
// Сначала указываются позиционные параметры. Например, эти три атрибута являются валидными:
[Test("A")]
public class A{}

[Test("B", C=3, B=2)]
public class B{}

[Test("C", A=1, C=0, B=2)]
public class C{}

void Main()
{
	var A = new A();
	var B = new B();
	var C = new C();
	
	ReflectionDumper<A>.Dump(); // A: 0; B: 0; C: 0
	ReflectionDumper<B>.Dump(); // A: 0; B: 2; C: 3
	ReflectionDumper<C>.Dump(); // A: 1; B: 2; C: 0
}
```  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Данные о атрибутах описывающих каждый класс достаються с помощью рефлексии:  
```c#
public static class ReflectionDumper<T> where T : class
{
	public static void Dump()
	{
		Type t = typeof(T);
    	object[] attrs = t.GetCustomAttributes(false);
		attrs.Dump();
	}
}
```  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В то ж время пока к классу с атрибутом не применена рефлексия, атрибут не размещается в памяти, и никакого влияния на данный класс не оказывает.

___
12. ### В чем различие между Finalize и Dispose?  
**Dispose**  
 Нужен для освобождения ресурсов "здесь и сейчас" (не совсем так на самом деле. Вызов Dispose сигнализирует, что вы хотите освободить ресурс, но не факт, что это обязательно случится вот прямо тут же). Необходимость и преимущество интерфейса `IDisposable` именно в том, что его реализация позволяет освобождать ресурсы не тогда, когда до них доберется сборщик мусора, а тогда, когда это нужно программисту. Ресурсы могут быть дорогими, и держать их в памяти неопределенно долгое время может быть слишком расточительным. Деструкторов в C# нет вовсе. Есть финализаторы. Разница в том, что время вызова финализатора не определено. Стоит также отметить, что если Dispose предназначен для вызова вручную, то финализатор вручную вызвать нельзя. Это делается автоматически.

 **Finalize**  
 Выполняется перед уничтожением объекта. Можно сказать, что это "последний шанс" освободить ресурсы корректно. Можно также считать, что Finalize - это "последняя воля умирающего" объекта. Определять этот метод имеет смысл только в случае, если класс имеет доступ к каким-либо неуправляемым ресурсам.  

___
13. ### Что такое Boxing и Unboxing?  
**Boxing**    - механизм который позволяет хранить данные типа значения внутри ссылочной переменной.
**Unboxing**  - представляет собой процесс преобразования значения, хранящегося в объ­ектной ссылке, обратно в соответствующий тип значения в стеке.

Пример задачи на собеседовании:
```c#
object box = (int)42;
long unbox = (long)box;
```
Так как переменная box - являеться ссылкой на область в heap`e, то операция приравнивания являеться не приведением типов а распаковкой типа. И правильным отметом к задаче выше будет слеующий код:
```c#
object box = (int)42;
long unbox = (long)(int)box;
```

При работе с Nullable типами, следует помнить, что boxing идет именно самого значения, так как тип Nullable являеться оберткой, с флагом о наличии значения, пример:
```c#
object box = (int?)1;   
int  unbox = (int)box; 
```
Пакуется не Nullable, а его значение. Если спросить у полученного box его тип через GetType(), то вы получите int, а не Nullable. Если значения нет — после запаковки получается null. Поэтому такой вещи, как **«распаковка из Nullable»**, просто не существует.

Так же из примеров boxing`а можно привести следующий код:
```c#
// Преобразование типа значений в ссылку на реализуемый им интерфейс
IComparable<int> a = 1;
// Преобразование типа enum в ссылку на System.Enum
Enum b = UriFormat.Unescaped; // System.UriFormat anyway 
// Преобразование типа значений к типу dynamic
dynamic c = 1;
```  

Для работы с упаковкой и распаковкой, следует знать что вместе с ними следуют и проблемы произоводительности, и следует избегать многократного использования того или иного механизма.  

**UNBOXING** - работает от 3-7раз быстрее **BOXING**!  

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Это заключаеться в том что выделением памяти в стэке, занимается `JIT compiler`, и количество нужной памяти уже изместно на момент компиляции. А так как unboxing занимаеться преобразованием объектной ссылки обратно в тип значания, который храниться в стэке, то работа по выделению памяти при использовании этого механизма минимальна времязатратна. А при использовании boxing, наоборот, в управляемой куче выделяется память длиной значимого типа и двумя дополнительными полями(необходимыми для всех объектов в управляемой куче: указатель на объект-тип и `SyncBlockIndex`), значение значимого типа копируется в кучу, возвращается адрес объекта.  


**!!!ВАЖНО!!!** Существуют и другие "рабочие" варианты, не являющисимя правильными при распаковке, например:
```c#
public enum EnumType { None }

object box = (int)42;
long unbox = (long)(EnumType)box; // unbox.GetType() = System.int64(long)
```  
**explicit** и **implicit**:  
Когда вы бодро и уверенно рассказали о упаковке и распаковке, скорее всего, вас спросят о том, что такое implicit и explicit. Это просто: explicit – явное преобразование, а implicit, наоборот, неявное. Как это выглядит в коде:  
```c#
int i = 146;
//implicit
object o = i;
```  
```c#
int i = 146;
//explicit
object o = (object)i;
```  
___
14. ### Что такое GAC?  
**GAC - Global Assembly Cache**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;На каждом компьютере с установленной средой CLR имеется кэш кода на уровне компьютера, называемый глобальным кэшем сборок. В глобальном кэше сборок сохраняются сборки, специально предназначенные для совместного использования на компьютере несколькими приложениями.  

С помощью `gacutil.exe` можно подпистаь свою сборку и добавить ее в общий кэш, для уменьшения времени на ее проверку, т.к. все сборки занесенные в кэш имееют подпись и не нуждаються в многократной проверке, при использовании сборки.  
___
15. ### Какие типы можно использовать в предложении foreach?  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Оператор foreach выполняет оператор или блок операторов для каждого элемента в экземпляре типа, который реализует интерфейс `System.Collections.IEnumerable` или `System.Collections.Generic.IEnumerable<T>`. Оператор `foreach` не ограничивается этими типами. Он может применяться к экземпляру любого типа, который удовлетворяет следующим условиям:
 - Включает открытый метод `GetEnumerator` без параметров со следующим типом возвращаемого значения: класс, структура или тип интерфейса;  
 - Тип возвращаемого значения метода `GetEnumerator` должен содержать открытое свойство `Current` и открытый метод MoveNext без параметров с типом возвращаемого значения `Boolean`;

 **Фичи:**  
  - Начиная с версии C# 8.0, можно применять оператор `await` к инструкции `foreach`, если тип коллекции реализует интерфейс `IAsyncEnumerable<T>`.  
  - В любой момент в блоке операторов `foreach` вы можете прервать цикл с помощью оператора break или перейти к следующей итерации в цикле с помощью оператора `continue`. Также можно выйти из цикла `foreach` с помощью операторов `goto`, `return` или `throw`. 
  - Пример кода на C# 7.2 с использованием `Span<T>`:  
```c#
Span<int> storage = stackalloc int[10];
int num = 0;
foreach (ref int item in storage)
{
    item = num++;
}
// Output: 0 1 2 3 4 5 6 7 8 9
```

___
16. ### В чем различие между классом и структурой?  
+  

___
17. ### Что означает модификатор virtual?  
Дает возможность переопределить метод в классе наследнике с помощью ключевого слово ```override```

___
18. ### Чем отличается event от delegate?  
+  

___
19. ### Может ли класс реализовать два интерфейса, у которых объявлены одинаковые методы? Каким образом?  
+  

___
20. ### Поддерживает ли C# множественное наследование?  
no  

___
21. ### Кому доступны переменные с модификатором protected на уровне класса?  

___
22. ### Наследуются ли переменные с модификатором private?  

___
23. ### Опишите модификатор “protected internal”  

___
24. ### Назовите класс .NET, от которого наследуются все классы?  
system.object  

___
25. ### Что обозначает термин immutable (неизменяемый)?  

___
26. ### Какая разница между классами System.String и System.Text.StringBuilder?  
+  

___
27. ### Какое преимущество использования класса System.Text.StringBuilder перед System.String?  

___
28. ### Можно ли хранить разные типы данных в объекте класса System.Array?  

___
29. ### Объясните разницу между System.Array.CopyTo() и System.Array.Clone()?  
+  

___
30. ### Как отсортировать элементы массива в убывающем порядке?  
+  

___
31. ### As, is – что это, как применяется?  
+  

___
32. ### Какой синтаксис используется для указания класса родителя в C#?  

___
33. ### Можно ли запретить наследование от своего собственного класса?  

___
34. ### Можно ли разрешить наследование класса, но запретить перекрытие метода?  

___
35. ### Что такое абстрактный класс?  
+  

___
36. ### В каком случае вы обязаны объявить класс абстрактным?   

___
37. ### Что такое интерфейс класса?  
апи доступа(его паблик методы)  

___
38. ### Почему нельзя указать модификатор видимости для методов интерфейса?  
потому что он публичный лол  

___
39. ### Можно ли наследовать от нескольких интерфейсов?  
Да   

___
40. ### Назовите отличия между интерфейсом и абстрактным классом?  
+  

___
41. ### Назовите различия между структурами и классами.  
+  

___
42. ### В чем разница между абстрактными и виртуальными классами? Между виртуальными и абстрактными методами?  
+  

___
43. ### Dispose(), Finalize() – что это за методы, как используются в .NET?  
+  

___
44. ### Для чего в .NET используется конструкция using(…){…}? Причем тут IDisposable?  
+  

___
45. ### Назовите явное имя параметра, передаваемого в метод set свойства класса?  

___
46. ### Что обозначает ключевое слово “virtual” для метода или свойства?  

___
47. ### Чем перекрытый метод отличается от перегруженного метода?  

___
48. ### Можно ли объявить перекрытый метод статическим, если перекрываемый метод не является статическим?  

___
49. ### Что такое «сопутствующая сборка» (satellite assembly)?  

___
50. ### Какая наименьшая исполнимая единица в .NET?  
Сборка - наименьшая единица развертывания.
___
51. ### Что происходит в памяти при упаковке и распаковке значимого типа?  
+  

___
52. ### Рефлексия в C#. Возможно ли с помощью рефлексии в C# вызвать private метод другого класса?
Если да, то как?

Рефлексия представляет собой процесс выявления типов во время выполнения приложения. Каждое приложение содержит набор используемых классов, интерфейсов, а также их методов, свойств и прочих кирпичиков, из которых складывается приложение. И рефлексия как раз и позволяет определить все эти составные элементы приложения.
 
 Пример рефлексии, который позволяет вызвать private метод другого класса.
``` C#

using System.Reflection; 
 
class Program 
    { 
        static void Main(string[] args) 
        { 
            Another another = new Another(); 
            Type type = another.GetType(); 
 
            MethodInfo metin = type.GetMethod("Hex", BindingFlags.Instance | BindingFlags.NonPublic); 
            metin.Invoke(another, null); 
        } 
    } 
 
    class Another 
    { 
        void Hex() 
        { 
            Console.WriteLine("You are bigger!!"); 
            Console.ReadLine(); 
        } 
    } 

```

___
53. ### ref and out 
Использубтся для параметров метода. 

ref используется когда уже у нас инициализированна переменная за пределами метода и мы ее передаем по ссылке в нужный метод. Out - можно передавать переменную даже если она не инициализирована за пределами метода, но должна быть обязательно нициализирована в методе. 
54. ### Метаданные  

Результатом компилятора является **управляемый модуль**. Каждый управляемый модуль имеет таблицы метаданных. Есть два типа таблиц. 1 - описывающие типы данных и их члены, определнные в исзодном коде. 2 - описывающие типы данных и их члены, нак оторые имеются ссылки в исходном коде. 

Одни из немногих применений метаданным:
    **1.** Служит для облегчения написания и понимания кода. IntelliSense - анализирует метаданные что предпочтительно (методы, события, свойства) в каждом конкретном случае и какие параметры требуются конерктному методу. 
    **2.** В процессе верификации кода CLR считывает метаданные, чтобы убедиться, что код совершает только безопасные по отношению к типам действия. 
    **3.** Метаданные повзволяют сериализовать поля объекта. В случае передачи **сериализованных** данных на другой компьютер по сети, там можно произвести процесс **десериализации** и восстановить объект и его состояние уже на другой машине. 
    **4.** Позволяют сборщику мусора отслеживать жизненный цикл объектов, узнать типы объектов и определить какие поля ссылаются на другие объекты. 


55. ### Разница между интерфейсом и абстрактным классом. 

**Интерфейс** - позволяет нам определить функционал, без конкретной реализации. Обязывает типы, которые унаследованные от него гарантированно реализовывать указанные члены. 

**Абстрактный класс** - базовый класс, который не предполагает создания экземпляров и может содержать в себе нереализованные члены. Но при этом он может содержать в себе реализованные члены (методы и свойства), которые будут доступны наследникам. 

Абстрактные классы используются в основном тогда, когда необходима общая функциональность для родственных объектов. 

Интерфейсы используются для описания общего шаблона поведения для разрозненных типов. 
    
56. ### 
57. ### 
58. ### 
59. ### 
60. ### 
61. ### 
62. ### 
63. ### 
64. ### 


Описание паттернов проектирования. 
Ссылки на репозитории реализации. 
# Паттерны

### Dependency Injection

Внедрение зависимостей. Это способ создания объектов, которые зависят от других объектов. Система внедрения зависимостей предоставляет зависимые объекты, когда создает экземпляр класса.

### SOLID

S: Single Responsibility Principle (Принцип единственной ответственности).
Каждый класс должен отвечать только за свою задачу. 

O: Open-Closed Principle (Принцип открытости-закрытости).

L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).

I: Interface Segregation Principle (Принцип разделения интерфейса).

D: Dependency Inversion Principle (Принцип инверсии зависимостей).



### Паттерн наблюдатель. 

Паттерн наблюдаетель или "Observer"
Главная цель наблюдателя - уведомление всех заинтересованных объектов о событии или изменении состояния. 
Реализуется связь один ко многим между объектами таким образом, что при изменнии одного объекта, все зависящие от него, будут уведомлены об этом. По другому этот паттерн может быть описан как "Издатель - подписчик". 







Паттерн стратегия. 
Паттерн абстрактная фабрика. 



# pure JS

1. callbacks

Иными словами функция обратного вызова. Функция обратного вызова - это та функция, которая передается как параметр в другую функцию и выполняется после выполнения определенного условия. 

Пример синхронного вызова функции обратного вызова. 
```javascript

    function greeting(name) {
    alert('Hello ' + name);
    }

    function processUserInput(callback) {
    var name = prompt('Please enter your name.');
    callback(name);
    }

    processUserInput(greeting);

```

Пример асинхронного вызова 
```javascript
    async function pageLoader(callback) {
        const data = await fetch('/ru/docs/Словарь/функция_обратного_вызова')
        callback(data)
    }

    function onPageLoadingFinished(pageData) {
        console.log('Page was sucessfully loaded!')
        console.log('Response:')
        console.log(pageData)
    }

    pageLoader(onPageLoadingFinished)
```

Мы заранее не знаем, в какой момент времени произойдет выполнение функции fetch(). Но точно можем сказать, что результат выполнения будет выведет после ее завершения. 


2. promises
3. var let const



4. arrow functions
5. Prototypes

**Прототипы** - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга. 




6. modules
7. async await

Синтаксический сахар для использования PROMISE. 

8. EventLoop

Вопрос о том, как достигается "асинхронность" в однопоточном JavaScript.

```javascript
    function main() {
        console.log('1')
        setTimeout(function exec() {
            console.log('2')
        }, 0)
        console.log('3')
    }
    main() 
    // Output
    // 1
    // 3
    // 2
```
![How eventLoop works?](/video/eventLoop.gif)

Рассмотрим выполнение кода более подробно. 
 - Вызов функции **main** поместит ее в call stack (в качестве главного, высшего по порядку элемента (frame)). Далее в стек поместится первое выражение функции main (**console.log('1')**). Это выражение выполняется и, после выполнения, удаляется из стека. В консоль выводится **1**.
 - Следующее выражение (setTimeout() с коллбэком exec() и временем ожидания в 0 секунд) помещается в стек вызовов и начинается выполнение. Функция setTimeout использует API браузера для задержки вызова предоставленной функции. Элемент (frame) удаляется из стека сразу после завершения передачи таймера браузерному API.
 - **console.log('3')** помещается в стек, в то время как браузер запускает таймер для выполнения функции **exec()**. Время ожидания таймера - 0 секунд, поэтому callback **exec()** будет сразу помещена в **callback queue** сразу после того, как браузер его получит. 
 - После выполнения последнего выражения функции **main** (**console.log('3')**), элемент main удаляется из call stack, оставляя его пустым. Стек вызовов должен быть пустым, для того чтобы браузер поместил в него элемент из message queue. Именно по этой причине даже если в setTimeout указано время ожидания в 0 секунд, функция exec() не выполняется, пока не закончится выполнение всех элементов в стеке вызовов.
 - После того, как call stack освобождается, то функция из callback queue помещается в call stack и выполняется. 

 *Таким образом аргумент delay в setTimeout(function, delayTime) не означает точное время задержки, после которого функция выполнится. Он означает минимальное время ожидания, после которого в какой-нибудь момент времени, функция будет вызвана.*
 
9.
10.


# The interview questions Angular.


2. DOM
3. Shadow DOM
    Используется для инкапсуляции. Благодаря этому у компонента есть свое теневое дерево, к которому нельзя обратиться через селектор из главного документа. 
4.
5.
6.
7.
8.
9.
10.

# Тестирование

1. **Что такое тестирование?**
    
    Написание автоматизированных тестов , иными словами код, который проверяет код, и определение ожиданий, которым он должны соотвествовать эти тесты. 

2. **Зачем нужно тестирование?**
    - экономия времени.
    - ускорение разработки, после каждого изменения нет необходимости перепроверять всю систему. 
    - неотклонность от заданного сценария тестирования.
    - это мотивирует писать чистый, расширяемый, тестируемый код.     

3. **Юнит тесты**
    
    Это тестирование одной изолированной блок или фрагмент программы. (Прим. Функция)
    Являются одними из самых простых для написания. Здесь нет зависимостей и взаимодействий. У нас есть входные данные и мы можем ожидать некоторый результат. 

    Например.

    Рассмотрим данную функцию в нашем приложении. Она принимает параметры name и age и возвращает некоторый результат, содержащий данные параметры. 

    В примерах юнит и интеграционных тестов используется библиотека **JEST**. 
    
    ```javascript
        const generateText = (name, age) => {
            return `${name} (${age} years old)`
        }
    ```
    Пример юнит теста для это функции:
    ```javascript
        test('should output name and age', () => {
            const text = generateText('Max', 29)
            expect(text).toBe('Max (29 years old)')
        })
    ```
    Этот юнит тест проверяет, возвращает ли функция **generateText** ожидаемый результат. 

    Если мы сейчас изменим функцию например так:
    ```javascript
        const generateText = (name, age) => {
            return `${age} (${age} years old)`
        }
    ```
    то наш тест не пройдет. Так как наша функция вернет **'29 (29 years old)'** вместо **'Max (29 years old)'**. 

    Поэтому вы должны разделить ваше приложение на множество мелких модулей, которые вы можете протестировать индивидуально. Это приведет к более чистому и аккуратному коду. 

    По той же причине нужно писать как можно больше юнит тестов и это будет самая распространенная форма тестов в вашем проекте. Если вы протестируете все отдельные модули вашего приложения, то велика вероятность, что ваше приложение будет работать как часы. 


4. **Интеграционные тесты**
    
    Тестирует комбинацию фрагментов программы. (Прим. Тестирование функции, которая вызывает функцию)

    Интеграционные тесты сложнее чем юнит тесты, ведь здесь мы имеем дело с зависимостями. Эти зависимости также имееют влияние на рузультат нашего теста. Это вынуждает нас писать "хорошие" тесты, которые позволяют нам ярче понять, какой эффект приводит к какому результату. 

    Также важно протестировать юнит тестами зависимости , которые используются в функции для интеграционного тестирования. Это может напорядок сузить поле поиска, в случае появления неисправности. 

    Может возникнуть мнение, что если мы написали юнит тесты для всего, то интеграционные не нужны. 

    Пример функцииЮ для интеграционного теста:
    ```javascript
        exports.checkAndGenerate = (name, age) => {
            if (!validateInput(name, true, false) || !validateInput(age, false, true)) {
                return false
            }
            return generateText(name, age)
        }
    ```
    А это интеграционынй тест для нее:
    ```javascript
        test('should generate a valid text output', () => {
            const text = checkAndGenerate('Max', 29)
            expect(text).toBe('Max (29 years old)')
        })
    ```
    Здесь нет никакого специального синтаксиса. Это совершенно обычный тест, но нозывается так, потому что он тестирует функцию которая имеет зависимости. 

    Функция **checkAndGenerate** возвращает результат функции **generateText** в конце. Но до этого момента **checkAndGenerate** проверяет ввод. И она делает все это вызывая другие функции. Следовательно мы получили здесь зависимость. 

    Изменим функцию **checkAndGenerate**:

    ```javascript
        exports.checkAndGenerate = (name, age) => {
            if (validateInput(name, true, false) || !validateInput(age, false, true)) {
                return false
            }
            return generateText(name, age)
        }
    ```
    Я удалил **!** перед первым вызовом **validateInput**. 

    Теперь это нарушит логику этой функции, поскольку мы теперь некорректно обрабатываем результат **validateInput**. Таким образом, ни **validateInput**, ни **generateText** не нарушены, и все же **checkAndGenerate** даст неверный результат.    

5. **e2e tests (End-to-End or UI)**
    
    Проверяют весь путь взаимодействия с вашей программой. 

    Эти виды тестов имитируют определенный поток взаимодействия пользователя с вашим приложением. Это включает нажатие, ввод текста и т.д.

    И поскольку это связано с взаимодействием пользователя, нам нужен браузер. Фактически все тесты выполняются в браузере, но они не загружают ваше приложение. Им просто нужна JavaScript-среда браузера (то есть, по сути, пустое окно браузера, которое загружается за кулисами).

    Для end-to-end/ UI тестирования нам необходим браузер, который загружает наше приложение. И мы должны иметь возможность управлять этим браузером с помощью кода (чтобы мы могли программировать определенные взаимодействия с пользователем и моделировать их).

    Для end-to-end/ UI тестирования в этом примере мы используем библиотеку **puppeteer**.

    ```javascript
        test('should create an element with text and correct class', async () => {
            const browser = await puppeteer.launch({
                headless: true,
            })
            const page = await browser.newPage()
            await page.goto('localhost:3000/your-page')
            await page.click('input#name')
            await page.type('input#name', 'Anna')
            await page.click('input#age')
            await page.type('input#age', '28')
            await page.click('#btnAddUser')
            const finalText = await page.$eval('.user-item', el => el.textContent)
            expect(finalText).toBe('Anna (28 years old)')
        }, 10000)
    ```
    Вы можете заметить, что мы просто говорим браузеру, что делать. И в конце мы можем получить доступ к елементам DOM и проверить их состояние, значения, css классы - все, что мы хотим сделать. 
    
    [**Ссылка на репозиторий с примером**](https://github.com/EugeneVaida/js-testing-introduction)
    ![e2e test](/video/puppeteer.gif)

# Методологии 

1. ### Agile

    Agile - набор подходов по "гибкой" разработке ПО. 

    **Люди и взаимодействие** важнее процессов и инструментов
    **Работающий продукт** важнее исчерпывающей документации
    **Сотрудничество с заказчиком** важнее согласования условий контракта
    **Готовность к изменениям** важнее следования первоначальному плану

    То есть, не отрицая важности того, что справа,
    мы всё-таки больше ценим то, что слева.

    **Принципы Agile:**
    - Наивысшим приоритетом для нас является удовлетворение потребностей
    заказчика, благодаря регулярной и ранней поставке ценного программного
    обеспечения.

    - Изменение требований приветствуется, даже на поздних стадиях разработки.
    Agile-процессы позволяют использовать изменения для обеспечения заказчику
    конкурентного преимущества.

    - Работающий продукт следует выпускать как можно чаще, с периодичностью
    от пары недель до пары месяцев.

    - На протяжении всего проекта разработчики и представители бизнеса должны
    ежедневно работать вместе.

    - Над проектом должны работать мотивированные профессионалы. Чтобы
    работа была сделана, создайте условия, обеспечьте поддержку и полностью
    доверьтесь им.

    - Непосредственное общение является наиболее практичным и эффективным
    способом обмена информацией как с самой командой, так и внутри команды.

    - Работающий продукт — основной показатель прогресса.

    - Инвесторы, разработчики и пользователи должны иметь возможность
    поддерживать постоянный ритм бесконечно. Agile помогает наладить такой
    устойчивый процесс разработки.

    - Постоянное внимание к техническому совершенству и качеству
    проектирования повышает гибкость проекта.

    - Простота — искусство минимизации лишней работы — крайне необходима.

    - Самые лучшие требования, архитектурные и технические решения рождаются
    у самоорганизующихся команд.

    - Команда должна систематически анализировать возможные способы
    улучшения эффективности и соответственно корректировать
    стиль своей работы.


2. ### Scrum 

    Это уже конкретное направление Agile.  

    **Scrum – это «подход структуры»**. Над каждым проектом работает универсальная команда специалистов, к которой присоединяется еще два человека: владелец продукта и scrum-мастер. Первый соединяет команду с заказчиком и следит за развитием проекта; это не формальный руководитель команды, а скорее куратор. Второй помогает первому организовать бизнес-процесс: проводит общие собрания, решает бытовые проблемы, мотивирует команду и следит за соблюдением scrum-подхода.

    Scrum-подход делит рабочий процесс на равные спринты – обычно это периоды от недели до месяца, в зависимости от проекта и команды. Перед спринтом формулируются задачи на данный спринт, в конце – обсуждаются  результаты, а команда начинает новый спринт. Спринты очень удобно сравнивать между собой, что позволяет управлять эффективностью работы.
